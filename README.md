``` 
                              @@@@@@@\            @@\     
  ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀@@  __@@\           @@ |
⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⡈⢯⡉⠓⠦⣄⡀⠀⠀⠀⠀⠀ @@ |  @@ | @@@@@@\  @@ |  @@\  @@@@@@\   @@@@@@\  @@\   @@\ ⠀              
⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠻⣉⠹⠷⠀⠀⠀⠙⢷⡀⠀⠀⠀⠀@@@@@@@\ | \____@@\ @@ | @@  |@@  __@@\ @@  __@@\ @@ |  @@ |
⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠞⠀⠀⠀⠀⠀⠀⠀⢿⡇⠀⠀⠀ @@  __@@\  @@@@@@@ |@@@@@@  / @@@@@@@@ |@@ |  \__|@@ |  @@ |
⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⢈⡇⠀⠀⠀ @@ |  @@ |@@  __@@ |@@  _@@<  @@   ____|@@ |      @@ |  @@ |
⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠹⠝⠀⠀⠀⠀⠀⣼⠃⠀⠀⠀ @@@@@@@  |\@@@@@@@ |@@ | \@@\ \@@@@@@@\ @@ |      \@@@@@@  |
⠀ ⠀⠀⠀⠀⠀⠀⠀⣠⠞⠀⣀⣠⣤⣤⠄⠀⠀⢠⡏⠀⠀⠀⠀\_______/  \_______|\__|  \__| \_______|\__|       \______/  
⠀ ⠀⠀⠀⠀⠀⠀⠚⠢⠼⠿⠟⢛⣾⠃⠀⠀⠀⢸⡇⠀⠀⠀   
⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡴⣻⠃⠀⠀⠀⠀⢸⡉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀.@@  @@:                    @@@                - 
⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⣰⢻⡷⠁⠀⠀⠀⠀⠀⢸⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀ @@+  @@           @@#       @@%       @@@@@@@@@@@-  
⠀ ⠀⠀⠀⠀⠀⠀⠀⢰⢽⡟⠁⠀⠀⠀⠀⠀⠀⠀⣇⠀⠀⠀⠀⠀⠀⠀⠀ @@*   @@    #@-   -@@        @@%            =@@@     
⠀ ⠀⠀⠀⠀⠀⠀⠀⢾⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⡆⠀⠀⠀⠀⠀⠀:@@@=   @@ .@@@@.   %@@   #@@@@@@@@@@:      :@@%    
⠀ ⠀⠀⠀⠀⠀⠀⠀⢸⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⡀⠀⠀⠀ #@@@@=   @@@@@:      %@#        @@%        :@@@@@@@@@@: 
⠀ ⠀⠀⠀⠀⠀⠀⠀⠘⢧⣳⡀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣷⠀⠀⠀⠀ # %@=   @@:         %@* @      @@%      :@@@%-.    +@@@
⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠈⣷⣱⡀⠀⠀⠀⠀⣸⠀⠀⠀⠈⢻⣦⠀⠀⠀⠀ %@=   @@          %@@@@:     @@#     @@@-   :.    =@@
⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣷⡙⣆⠀⠀⣾⠃⠀⠀⠀⠀⠈⢽⡆⠀⠀⠀ %@=   @@      @@  *@@@      @@@       :  @@@%@@@. %@@
⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⡇⢷⡏⠃⢠⠇⠀⠀⣀⠄⠀⠀⠀⣿⡖⠀⠀ %@=   @@-    #@#   @@#    *@@@           @@+  %@@@@@ 
⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡇⢨⠇⠀⡼⢀⠔⠊⠀⠀⠀⠀⠀⠘⣯⣄⢀ %@=   -@@@@@@@@           @@.             -@@@@@@=   
⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⡇⣼⡀⣰⣷⠁⠀⠀⠀⠀⠀⠀⠀⠀⣇⢻⣧⡄      
⠀ ⠀⠀⠀⠀⠀⠀⣀⣮⣿⣿⣿⣯⡭⢉⠟⠛⠳⢤⣄⣀⣀⣀⣀⡴⢠⠨⢻⣿      Version 3.1.0
⠀ ⠀   ⢀⣾⣿⣿⣿⣿⢏⠓⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⢨⣿      
⠀    ⣰⣿⣿⣿⣿⣿⣿⡱⠌⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⢭⣾⠏        Tauri Application by @willnjohnson
    ⣰⡿⠟⠋⠛⢿⣿⣿⊊⠡⠀⠀⠀⠀⠀⠀⠀⠀ ⠀⢀⣠⣼⡿⠋⠀
   ⠋⠁⠀⠀⠀⠀⠈⠑⠿⢶⣄⣀⣀⣀⣀⣀⣄⣤⡶⠿⠟⠋⠁⠀⠀⠀        Written in Rust (inspired by C algorithm by Kvho)
```

# Bakeru (化ける) - A Neopets Shapeshifter Solver

**Bakeru (化ける)**, meaning "to transform" in Japanese, is a modern **Tauri Application** designed to help solve the Neopets game **Shapeshifter**. It features a Rust backend supplied with a low-level, pointer-optimized backtracking algorithm, paired with a clean React-based user interface.

Originally, when I built this tool, it was built as a Windows-only Visual Studio C# application. While functional, the interface was clunky and difficult to maintain. And the application was not cross-platform. This complete rewrite into the Tauri ecosystem provides that support, a more responsive UI, and improved solving speeds.

Official releases for Windows, Linux, and macOS can be found under the **[Releases](https://github.com/willnjohnson/Bakeru/releases)** section.

> [!IMPORTANT]
> Please add this **[GreaseMonkey script](https://greasyfork.org/en/scripts/566826-bakeru-web-visualizer-for-shapeshifter)** to your GreaseMonkey/TamperMonkey extension for browser convenience, which will:
> * Help quickly extract puzzle data with a "Copy HTML" button.
> * Provide visual symbol replacement to match the solver's clean interface.

> [!WARNING]
> App might fail to give proper steps at **Level 1** (i.e. provides 1 step instead of 2 steps), but hey, you can solve it... It's really easy!
> 
> But it works flawlessly for **Levels 2-100.**

## App Preview

https://github.com/user-attachments/assets/c0d20991-20ed-4c42-a806-5f160fa818a7

## Features

*   **Fast HTML Parsing:** Instantly extracts the grid state and token shapes from the Neopets source code.
*   **Native Performance:** Core solver implemented in Rust using raw pointers and aggressive optimization profiles, with better performance to the original C implementation.
*   **Asynchronous Solving:** The solver runs on a separate thread, keeping the UI fluid and responsive even during multi-minute searches for high-level puzzles.
*   **Progressive UI:** Visual board preview that updates with your progress through the solution steps.
*   **Symmetry Pruning:** Detects equivalent tokens to avoid redundant search permutations, critical for levels 40+.

## Puzzle Data

*   **Grid Layout:** The $M \times N$ board containing various token types.
*   **Token Sequence:** The specific set of puzzle shapes provided by the game for the current level.
*   **Goal:** The specific token type (usually swords) that all cells must match to win.

## Requirements

*   **Windows**: `.msi` installers.
*   **Linux**: `.AppImage`, `.deb`, or `.rpm` packages.
*   **macOS**: `.dmg` or `.app` bundles.
*   *Note: Binaries are available in the GitHub Releases section.*

## Usage

1.  **Launch the Bakeru application.**
2.  **Paste the HTML source** of your current Shapeshifter puzzle into the input area.
3.  **Click "Solve"** to begin the process.
4.  Follow the **Solution Steps** provided. You can check them off as you go.
5.  Hover over or click a step to see the placement highlighted on the board preview.

> [!TIP]
> If a puzzle seems impossible or the search is taking too long, lose the game on purpose to generate a new grid and try again!

## Output

Results are displayed in the "Solution Steps" sidebar. Each step is zero-padded (e.g., `Step 01:`) and provides coordinates in `Row Y, Col X` format. The main board view allows you to visualize the current state of the puzzle as you apply each step.

## Algorithms

Throughout its development, this project has explored several search strategies to conquer the Shapeshifter puzzle:

1.  **Recursive Depth-First Search (DFS):** The fundamental approach, exploring every possible placement sequence.
2.  **A-Star & IDA-Star (Iterative Deepening A-Star):** Guided search using the number of non-goal cells as a heuristic. While robust, these often suffered from high memory usage or redundant re-explorations.
3.  **The Chosen Approach: Optimized Backtracking with Symmetry Pruning:** 
    *   **Low-Level Rust Implementation:** Uses raw pointers to achieve performance parity with original C solver.
    *   **In-Place State Toggling:** Modifies the grid state directly and reverses changes during backtracking to avoid expensive allocations.
    *   **Pruning:** Aggressively prunes branches using a "toggle budget" and by identifying equivalent token shapes to skip redundant permutations.

---

## Further Reading

*   **ShapeShifter algorithm:** [Dr. Plank's lab writeup explanation](https://web.archive.org/web/20240418234629/https://web.eecs.utk.edu/~jplank/plank/classes/cs202/Labs/Lab9/)
*   **A-Star Heuristic search:** [CMU AI Course PDF](https://www.cs.cmu.edu/~cga/ai-course/astar.pdf)
*   **She Who Shapes:** [Historical Shapeshifter Resource](https://shewhoshapes.wordpress.com/)

---

## Speed Comparison

The app has evolved through a couple iterations:

1. **Version 1 (C#)** – The backtracking and pruning algorithm was written entirely in C#. Performance was slow for larger inputs.  
2. **Version 2 (C DLL)** – Ported Kvho’s code to a C DLL and integrated it into the C# app, improving speed significantly.  
3. **Version 3 (Rust + Tauri)** – Reimplemented Kvho’s 532-line algorithm in Rust (199 lines excluding comments and whitespace) and integrated it into a Tauri app. 

**Left: Tauri app using Rust (18.51s) v.s. Right: Visual C# app using C DLL (~24-25s)**

![Speed Comparison](https://github.com/user-attachments/assets/022e97da-e924-4b11-80bb-a541875d0f9a)

On level 48, the Rust implementation yields an additional ~6 seconds of improvement over the C DLL version, quite a noticeable speedup while reducing code size.

**Note:** This is by no means a full benchmark. However, from my experience, this Rust implementation is faster.

---

## Contributions

Special thanks to [Kvho](https://raw.githubusercontent.com/jimrustle/neopets-shapeshifter/1c31a419971de3f25cac9a5dfc4fa32ca4aa7605/kvho_ss/ss.c) for the highly optimized DFS backtracking logic implemented in C, the inspiration for the now robust Rust port.

---

## License

This project is open-source and available under the MIT License.

**Disclaimer:** "Neopets" is a registered trademark of Neopets, Inc. This application is an unofficial fan-made helper and is not affiliated with or endorsed by Neopets, Inc.
